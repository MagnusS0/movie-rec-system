{"timestamp": 1694907044.524941, "stored_source_code": "# declare a list tasks whose products you want to use as inputs\nupstream = None\n\nimport requests\nfrom dotenv import load_dotenv\nimport json\nimport tempfile\nimport duckdb\nimport os\nimport logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\ndef extract_movies(api_key=None, lang='en', num_movies=100, conn=None, drop=False):\n    \"\"\"\n    Extracts movies from TheMovieDB API and populates the DuckDB database.\n\n    Args:\n        api_key (str): The API key for accessing TheMovieDB.\n        lang (str, optional): The language code for movie data. Defaults to 'en'.\n        num_movies (int, optional): The number of movies to extract. Defaults to 100.\n        conn: The DuckDB connection object.\n        drop (bool, optional): Whether to drop the existing table before insertion. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    movies = 0\n    page = 1\n\n    # Drop table if drop = True\n    drop_table(conn, drop=drop, table_name='movies')\n\n    while movies < num_movies:\n        # Update the URL with the new page number\n        url = f\"https://api.themoviedb.org/3/movie/popular?api_key={api_key}&with_original_language={lang}&page={page}\"\n\n        # Make a request\n        try:\n            res = requests.get(url)\n        except requests.exceptions.RequestException as e:\n            logging.error(f\"An error occurred during the request: {e}\")\n            break\n\n        if res.status_code != 200:\n            logging.error(f\"Received non-200 status code: {res.status_code}\")\n            break\n\n        # Transform content to JSON\n        json_data = res.json()\n\n        # Initialize or update the database\n        init_duck_db_movies(conn, json_data, table_name='movies')\n\n        # Log progress\n        movies += len(json_data.get('results', []))\n        logging.info(f\"Extracted {movies} out of {num_movies} movies.\")\n\n        page += 1\ndef extract_genre(api_key=None, lang='en', drop=False, conn=None):\n    \"\"\"\n    Extracts movie genres from TheMovieDB API and returns the data as a JSON object.\n\n    Args:\n        api_key (str): The API key for accessing TheMovieDB.\n        lang (str, optional): The language code for genre data. Defaults to 'en'.\n        conn: The DuckDB connection object.\n\n    Returns:\n        dict: A JSON object containing the API response.\n    \"\"\"\n    # Drop table if drop = True\n    drop_table(conn, drop=drop, table_name='genres')\n\n    # Construct URL\n    url = f\"https://api.themoviedb.org/3/genre/movie/list?api_key={api_key}&with_original_language={lang}\"  # noqa E501\n    # Make a request\n    try:\n        res = requests.get(url)\n    except requests.exceptions.RequestException as e:\n        logging.error(\"An error occurred during the request:\", e)\n        return {}\n\n    # Transform content to JSON\n    json_data = res.json()\n\n    # Initialize or update the database\n    init_duck_db_genres(conn, json_data, table_name='generes')\n\ndef drop_table(conn, drop=False, table_name=None):\n    '''\n    Drops table in DuckDB if it does exist\n\n    Args:\n        conn: The DuckDB connection object.\n        table_name (str): The name of the table to create or update.\n        drop (bool, optional): Whether to drop the table if it already exists. Defaults to False.\n\n    Returns:\n        None\n    '''\n    # If drop flag is True, drop the existing table\n    if drop:\n        conn.execute(f\"DROP TABLE IF EXISTS {table_name}\")\n        logging.info(f'Sucessfully dropped {table_name}')\ndef write_json_to_temp_file(json_data):\n    \"\"\"\n    Writes the provided JSON data to a temporary file and returns the file's name.\n\n    Args:\n        json_data (dict): The JSON data to write to the file.\n\n    Returns:\n        str: The name of the temporary file containing the JSON data, or None if an error occurs.\n    \"\"\"\n    # Write JSON string to a temporary file\n    try:\n        with tempfile.NamedTemporaryFile(delete=False, mode='w') as temp_file:\n            json.dump(json_data, temp_file)\n            return temp_file.name\n    except Exception as e:\n        logging.error(f\"An error occurred while writing the JSON file: {e}\")\n        return None\ndef create_table(conn, table_name, temp_file_path):\n    \"\"\"\n    Creates a new table in DuckDB if it does not already exist, or inserts data into an existing table.\n    Optionally drops the table if it already exists.\n\n    Args:\n        conn: The DuckDB connection object.\n        table_name (str): The name of the table to create or update.\n        temp_file_path (str): The path to the temporary file containing the JSON data to populate the table.\n\n    Returns:\n        None\n    \"\"\"\n    # If table do NOT exists create a new one, else insert data\n    try:\n        tables = conn.execute(\"SHOW TABLES;\").fetchall()\n\n        if (f\"{table_name}\",) not in tables:\n            conn.execute(\n                f\"CREATE TABLE {table_name} AS SELECT * FROM read_json_auto('{temp_file_path}')\")\n        else:\n            conn.execute(\n                f\"INSERT INTO {table_name} SELECT * FROM read_json_auto('{temp_file_path}')\")\n    except Exception as e:\n        logging.error(f\"An error occurred while creating the table: {e}\")\n        return\ndef init_duck_db_movies(conn, json_data=None, table_name='movies'):\n    '''\n    Initilizes the 'movies' table and populates it with JSON data\n\n    Args:\n        conn : The DuckDB connection object.\n        json_data (dict, optional) : The JSON data to populate the table with. If None, data will be extracted\n        using the extract_movies function. Defaults to None. \n        table_name (str, optional): The name of the table to initialize. Defaults to 'movies'.\n\n    Returns:\n        None\n    '''\n\n    # Write JSON string to a temporary file\n    if json_data:\n        temp_file_path = write_json_to_temp_file(json_data)\n\n        # If table do NOT exists create a new one, else insert data\n        if temp_file_path:\n            create_table(conn, table_name, temp_file_path)\n            os.remove(temp_file_path)\n            logging.info(\n                f\"Successfully initialized and populated the table {table_name}.\")\ndef init_duck_db_genres(conn, json_data=None, table_name='genres'):\n    '''\n    Initilizes the 'genres' table and populates it with JSON data\n\n    Args:\n        conn : The DuckDB connection object.\n        path (str, optional) : The path to the DuckDB file. Defaults to \"movies_data.duckdb\".\n        json_data (dict, optional) : The JSON data to populate the table with. If None, data will be extracted\n        table_name (str, optional): The name of the table to initialize. Defaults to 'genres'.\n\n    Returns:\n        None\n    '''\n\n    # Write JSON string to a temporary file\n    if json_data:\n        temp_file_path = write_json_to_temp_file(json_data)\n\n        # If table do NOT exists create a new one, else insert data\n        if temp_file_path:\n            create_table(conn, table_name, temp_file_path)\n            os.remove(temp_file_path)\n            logging.info(\n                f\"Successfully initialized and populated the table {table_name}.\")\nif __name__ == \"__main__\":\n    # Parameter to get 1000 English movies\n    language_count = {\"en\": 1000,}\n\n    # Load API key from .env file\n    load_dotenv(\".env\")\n    api_key = os.getenv('API_KEY')\n\n    conn = None\n\n    # Initialize connection path\n    duckdb_file_path = \"movies_data.duckdb\"\n    try:\n        conn = duckdb.connect(duckdb_file_path, read_only=False)\n        logging.info('Connection opened')\n        \n        for key in language_count:\n        # print(key,language_count[key])\n            print(\"Downloading\", key, end=\": \")\n            movies = extract_movies(api_key, key, language_count[key],conn,drop=True)  # noqa E501\n            genres = extract_genre(api_key, key,drop=True, conn=conn)\n\n    except Exception as e:\n        logging.error(f'An error occurred: {e}')\n\n    finally:\n        if conn:\n            conn.close()\n            logging.info('Connection closed')", "params": {}}